<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Zen Sanctuary</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        body { display: flex; align-items: center; justify-content: center; }
        canvas {
            display: block;
            width: 100vw;
            height: 100dvh;
            touch-action: none;
        }
        noscript {
            color: #aaa; font-family: sans-serif; text-align: center;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        /* ── Chat UI ─────────────────────────────────────────────── */
        #chat-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            pointer-events: none;
            z-index: 100;
        }

        #chat-response {
            max-width: 500px;
            width: 90%;
            margin-bottom: 16px;
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            color: rgba(255, 255, 255, 0.85);
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 15px;
            line-height: 1.5;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            pointer-events: auto;
        }

        #chat-response.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #chat-response.thinking {
            opacity: 0.6;
        }

        #chat-input-wrapper {
            max-width: 400px;
            width: 85%;
            display: flex;
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 4px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            pointer-events: auto;
        }

        #chat-input-wrapper:focus-within {
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.05);
        }

        #chat-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            padding: 12px 16px;
            color: rgba(255, 255, 255, 0.9);
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 15px;
        }

        #chat-input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }

        #chat-send {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 20px;
            padding: 10px 16px;
            color: rgba(255, 255, 255, 0.7);
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        #chat-send:hover {
            background: rgba(255, 255, 255, 0.18);
            color: rgba(255, 255, 255, 0.95);
        }

        #chat-send:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* ── Voice Button ─────────────────────────────────────────────── */
        #voice-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            margin-right: 4px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #voice-btn:hover {
            background: rgba(255, 255, 255, 0.18);
            color: rgba(255, 255, 255, 0.95);
        }

        #voice-btn.listening {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
            animation: pulse-mic 1.5s ease-in-out infinite;
        }

        #voice-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #voice-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        @keyframes pulse-mic {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @media (max-width: 480px) {
            #chat-container { padding: 12px; }
            #chat-response { font-size: 14px; padding: 12px 16px; }
            #chat-input { font-size: 14px; padding: 10px 14px; }
            #chat-send { padding: 8px 12px; font-size: 13px; }
            #voice-btn { width: 36px; height: 36px; }
        }

        /* ── Desktop Enhancements ─────────────────────────────────── */
        @media (min-width: 769px) {
            #chat-container {
                padding: 30px;
                padding-bottom: 40px;
            }
            #chat-response {
                max-width: 550px;
                font-size: 16px;
                padding: 18px 24px;
                margin-bottom: 20px;
            }
            #chat-input-wrapper {
                max-width: 480px;
            }
            #chat-input {
                font-size: 16px;
                padding: 14px 20px;
            }
            #chat-send {
                padding: 12px 20px;
                font-size: 15px;
            }
            #voice-btn {
                width: 44px;
                height: 44px;
            }
            #voice-btn svg {
                width: 20px;
                height: 20px;
            }
        }

        /* ── Large Desktop / Ultrawide ────────────────────────────── */
        @media (min-width: 1200px) {
            #chat-container {
                padding: 40px;
                padding-bottom: 50px;
            }
            #chat-response {
                max-width: 600px;
            }
            #chat-input-wrapper {
                max-width: 520px;
            }
        }

        /* ── Connection Status ─────────────────────────────────────── */
        #zen-status {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            z-index: 100;
        }

        #zen-status.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #zen-status .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        #zen-status.online .dot {
            background: #4ade80;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }

        #zen-status.offline .dot {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
        }

        #zen-status.checking .dot {
            background: #fbbf24;
            animation: pulse 1s ease-in-out infinite;
        }

        #zen-status.listening .dot {
            background: #60a5fa;
            box-shadow: 0 0 8px rgba(96, 165, 250, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        #zen-status.waking .dot {
            background: #fbbf24;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        /* Always-listening mode indicator */
        #voice-btn.always-on {
            background: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
            box-shadow: 0 0 12px rgba(96, 165, 250, 0.3);
        }

        #voice-btn.always-on.listening {
            background: rgba(96, 165, 250, 0.3);
            animation: pulse-listen 2s ease-in-out infinite;
        }

        @keyframes pulse-listen {
            0%, 100% { box-shadow: 0 0 12px rgba(96, 165, 250, 0.3); }
            50% { box-shadow: 0 0 20px rgba(96, 165, 250, 0.6); }
        }
    </style>
</head>
<body>
    <canvas id="zenCanvas" role="img" aria-label="Zen Sanctuary: an ambient animated clock"></canvas>
    <noscript>Zen Sanctuary requires JavaScript to display the ambient clock.</noscript>

    <!-- Connection Status -->
    <div id="zen-status">
        <span class="dot"></span>
        <span class="label">Connecting...</span>
    </div>

    <!-- Chat UI -->
    <div id="chat-container">
        <div id="chat-response"></div>
        <div id="chat-input-wrapper">
            <button id="voice-btn" title="Voice input">
                <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1 1.93c-3.94-.49-7-3.85-7-7.93h2c0 3.31 2.69 6 6 6s6-2.69 6-6h2c0 4.08-3.06 7.44-7 7.93V20h4v2H8v-2h4v-4.07z"/></svg>
            </button>
            <input type="text" id="chat-input" placeholder="Ask Zen anything..." autocomplete="off">
            <button id="chat-send">Send</button>
        </div>
    </div>

<script>
(() => {
"use strict";

// ── State ──────────────────────────────────────────────────────────
const canvas = document.getElementById('zenCanvas');
const ctx = canvas.getContext('2d');
const TWO_PI = Math.PI * 2;

const state = {
    w: 0, h: 0, cx: 0, cy: 0, dpr: 1,
    baseSize: 0,
    maxClockRadius: 0,
    innerRadius: 0,
    lastMin: -1,
    lastSec: -1,
    coreFlash: 0,
    ghostAlpha: 0,
    ghostTimer: 0,
    chargeEnergy: 0,
    lastFrameTime: 0,
    isMobile: false,
    // Idle mode
    lastInteraction: 0,   // timestamp of last touch/pointer
    idleAmount: 0,        // 0 = active, 1 = fully idle
};

let minuteRings = [];
let sparks = [];
let ripples = [];
let touchRipples = [];
let weatherParticles = [];
let constellationAlpha = 0;
let constellationCooldown = 0;

// ── Resize ─────────────────────────────────────────────────────────
function resize() {
    state.dpr = Math.min(window.devicePixelRatio || 1, 2);
    state.w = window.innerWidth;
    state.h = window.innerHeight;
    state.isMobile = state.w < 768;

    // Calculate available space accounting for chat UI at bottom
    const chatHeight = state.isMobile ? 120 : 160;
    const availableHeight = state.h - chatHeight;

    // Center the clock in the available space (above chat)
    state.cx = state.w / 2;
    state.cy = availableHeight / 2;

    canvas.width = state.w * state.dpr;
    canvas.height = state.h * state.dpr;
    ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

    // Use the smaller of width or available height for proportional sizing
    state.baseSize = Math.min(state.w, availableHeight);

    // Scale clock based on screen type
    let clockScale;
    if (state.isMobile) {
        clockScale = 0.40;
    } else if (state.w >= 1200) {
        // Large desktop - slightly larger clock
        clockScale = 0.38;
    } else {
        // Regular desktop
        clockScale = 0.36;
    }

    state.innerRadius = state.baseSize * 0.08;
    state.maxClockRadius = state.baseSize * clockScale;

    // Rebuild rings preserving glow state
    const oldGlows = minuteRings.map(r => r.glow);
    minuteRings = [];
    for (let i = 1; i <= 60; i++) {
        const t = i / 60;
        const r = state.innerRadius + t * (state.maxClockRadius - state.innerRadius);
        minuteRings.push({ r, glow: oldGlows[i - 1] || 0 });
    }

    // Rebuild sparks — 20 ambient orbiters that collectively respond to time
    const sparkCount = state.isMobile ? 14 : 20;
    while (sparks.length < sparkCount) {
        sparks.push(createSpark(sparks.length));
    }
    sparks.length = sparkCount;
    sparks.forEach((p) => {
        p.outerOrbit = state.maxClockRadius * 0.7;
        p.innerTarget = state.innerRadius * 0.6;
    });

    // Rebuild weather particles
    const weatherCount = state.isMobile ? 30 : 60;
    while (weatherParticles.length < weatherCount) {
        weatherParticles.push(createWeatherParticle());
    }
    weatherParticles.length = weatherCount;
}

function createSpark(index) {
    return {
        index: index || 0,
        angle: Math.random() * TWO_PI,
        dist: 0,
        outerOrbit: state.maxClockRadius * 0.7,
        innerTarget: state.innerRadius * 0.6,
        size: Math.random() * 1.2 + 0.8,
        baseSpeed: (Math.random() * 0.006 + 0.003) * (Math.random() > 0.5 ? 1 : -1),
        trail: [],
        lastRingCross: -1, // for ring interaction tracking
        scattered: 0,      // scatter force from touch
        scatterAngle: 0,
    };
}

function createWeatherParticle() {
    return {
        x: Math.random() * (state.w || 800),
        y: Math.random() * (state.h || 600),
        size: Math.random() * 1.5 + 0.3,
        drift: (Math.random() - 0.5) * 0.3,
        fallSpeed: Math.random() * 0.3 + 0.1,
        alpha: Math.random() * 0.15 + 0.02,
        wobble: Math.random() * TWO_PI,
        wobbleSpeed: Math.random() * 0.02 + 0.005,
    };
}

let resizeTimer;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resize, 100);
});
resize();

// ── Interaction ────────────────────────────────────────────────────
function addTouchRipple(x, y) {
    touchRipples.push({ x, y, r: 5, a: 1.2, v: state.baseSize * 0.004 });
}

let longPressTimer = null;
let pressPos = { x: 0, y: 0 };

canvas.addEventListener('pointermove', (e) => {
    state.lastInteraction = performance.now();
    // Cancel long press if finger/mouse drifts too far
    if (longPressTimer) {
        const dx = e.clientX - pressPos.x;
        const dy = e.clientY - pressPos.y;
        if (dx * dx + dy * dy > 100) { // ~10px drift tolerance
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }
});

canvas.addEventListener('pointerdown', (e) => {
    state.lastInteraction = performance.now();
    const px = e.clientX;
    const py = e.clientY;
    pressPos = { x: px, y: py };
    addTouchRipple(px, py);

    // Scatter sparks away from touch point
    sparks.forEach(p => {
        const sparkX = state.cx + Math.cos(p.angle) * p.dist;
        const sparkY = state.cy + Math.sin(p.angle) * p.dist;
        const sdx = sparkX - px;
        const sdy = sparkY - py;
        const sDist = Math.sqrt(sdx * sdx + sdy * sdy);
        const scatterRange = state.baseSize * 0.25;
        if (sDist < scatterRange) {
            const force = (1 - sDist / scatterRange) * state.baseSize * 0.15;
            p.scattered = force;
            p.scatterAngle = Math.atan2(sdy, sdx);
        }
    });

    // Long press (500ms) — reveal the time ghost label
    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => {
        state.ghostTimer = 600;
        state.coreFlash = Math.max(state.coreFlash, 1.5);
        longPressTimer = null;
    }, 500);
});

canvas.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    longPressTimer = null;
});
canvas.addEventListener('pointercancel', () => {
    clearTimeout(longPressTimer);
    longPressTimer = null;
});

// ── Theme ──────────────────────────────────────────────────────────
function getChronoTheme() {
    const now = new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const s = now.getSeconds();
    const ms = now.getMilliseconds();
    const secFrac = s + ms / 1000;
    const dayProgress = (h + m / 60 + s / 3600) / 24;

    // Circadian: brighter midday, darker at night
    const circadianLume = 5 + Math.sin(dayProgress * Math.PI) * 12;
    const isAM = h < 12;

    // AM/PM tint: AM shifts warm (+15 hue toward amber), PM shifts cool (-15 toward blue)
    const ampmShift = isAM ? 15 : -15;
    const baseHue = ((h * 15 + (m / 60) * 15) + ampmShift + 360) % 360;

    // Charge cycle: agent builds energy during last 8 seconds of each minute
    const chargeStart = 52;
    const isCharging = s >= chargeStart;
    const chargePower = isCharging ? (secFrac - chargeStart) / (60 - chargeStart) : 0;
    const isHourFinale = m === 59 && s >= 52;

    // Circadian energy: peaks at noon, lowest at midnight
    // Used for spark speed, trail length, weather behavior
    const circadianEnergy = Math.sin(dayProgress * Math.PI); // 0..1..0 over 24h

    return {
        baseHue,
        circadianLume,
        circadianEnergy,
        dayProgress,
        core:  `hsl(${baseHue}, 90%, 75%)`,
        ring:  `hsl(${baseHue}, 55%, 45%)`,
        ringLit: `hsl(${baseHue}, 70%, 60%)`,
        bg:    `hsl(${baseHue}, 35%, ${circadianLume}%)`,
        glow:  `hsl(${baseHue}, 50%, ${circadianLume + 12}%)`,
        spark: `hsl(${baseHue}, 100%, 90%)`,
        quarter: `hsl(${(baseHue + 30) % 360}, 80%, 75%)`,
        chargePower, isCharging, isHourFinale, isAM,
        h, m, s, ms, secFrac,
    };
}

// ── Drawing Helpers ────────────────────────────────────────────────
function drawCircle(x, y, radius) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, TWO_PI);
}

// ── Main Loop ──────────────────────────────────────────────────────
function loop(timestamp) {
    if (!state.lastFrameTime) state.lastFrameTime = timestamp;
    const dt = Math.min((timestamp - state.lastFrameTime) / 16.667, 3);
    state.lastFrameTime = timestamp;

    const theme = getChronoTheme();
    const { cx, cy, w, h, baseSize, maxClockRadius, innerRadius } = state;
    const maxScreenDist = Math.sqrt(cx * cx + cy * cy);

    // ── Background ─────────────────────────────────────────────
    {
        const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxScreenDist);
        bgGrad.addColorStop(0, theme.glow);
        bgGrad.addColorStop(1, theme.bg);
        ctx.fillStyle = bgGrad;
    }
    ctx.globalAlpha = 1;
    ctx.fillRect(0, 0, w, h);

    // ── Idle Mode ────────────────────────────────────────────────
    // After 1 minute of no interaction, gradually enter meditation state
    const IDLE_THRESHOLD = 60000; // 1 minute in ms
    const IDLE_RAMP = 30000;      // 30 seconds to fully transition
    const timeSinceInteraction = timestamp - (state.lastInteraction || timestamp);
    const idleTarget = timeSinceInteraction > IDLE_THRESHOLD
        ? Math.min(1, (timeSinceInteraction - IDLE_THRESHOLD) / IDLE_RAMP)
        : 0;
    state.idleAmount += (idleTarget - state.idleAmount) * 0.02 * dt;
    const idle = state.idleAmount;

    // ── Ambient Particle Weather (#6) ──────────────────────────
    // Background dust/motes that drift with time-of-day character:
    //   Morning (0.2-0.4): rising upward like dawn mist
    //   Midday  (0.4-0.6): gentle lateral drift, most visible
    //   Evening (0.6-0.8): settling downward
    //   Night   (0.8-1.0, 0-0.2): slow, sparse, barely visible
    {
        const dp = theme.dayProgress;
        const isMorning = dp > 0.2 && dp < 0.45;
        const isEvening = dp > 0.6 && dp < 0.85;
        const nightFade = theme.circadianEnergy; // low at night, high midday

        weatherParticles.forEach(wp => {
            wp.wobble += wp.wobbleSpeed * dt;

            // Vertical drift direction based on time of day
            let vertDir = 0;
            if (isMorning) vertDir = -1;       // rise
            else if (isEvening) vertDir = 1;   // settle
            else vertDir = Math.sin(wp.wobble) * 0.3; // gentle float

            const idleSlow = 1 - idle * 0.6; // slower drift when idle
            wp.x += (wp.drift + Math.sin(wp.wobble) * 0.4) * dt * idleSlow;
            wp.y += (wp.fallSpeed * vertDir + Math.cos(wp.wobble * 0.7) * 0.15) * dt * idleSlow;

            // Charge phase: weather swirls toward center
            if (state.chargeEnergy > 0.1) {
                const wdx = cx - wp.x;
                const wdy = cy - wp.y;
                const wDist = Math.sqrt(wdx * wdx + wdy * wdy) || 1;
                wp.x += (wdx / wDist) * state.chargeEnergy * 1.5 * dt;
                wp.y += (wdy / wDist) * state.chargeEnergy * 1.5 * dt;
            }

            // Wrap around screen
            if (wp.x < -10) wp.x = w + 10;
            if (wp.x > w + 10) wp.x = -10;
            if (wp.y < -10) wp.y = h + 10;
            if (wp.y > h + 10) wp.y = -10;

            // Draw — visibility scales with circadian energy; more visible when idle
            ctx.globalAlpha = wp.alpha * (0.15 + nightFade * 0.85) * (1 + idle * 1.5);
            ctx.fillStyle = theme.spark;
            ctx.beginPath();
            ctx.arc(wp.x, wp.y, wp.size, 0, TWO_PI);
            ctx.fill();
        });
    }

    // ── Minute Change: Agent fires a ring ──────────────────────
    if (theme.m !== state.lastMin && state.lastMin !== -1) {
        state.coreFlash = 3.0;
        ripples.push({
            r: innerRadius,
            a: 1.8,
            isHour: false,
            v: baseSize * 0.004,
        });
    }
    state.lastMin = theme.m;

    // ── Hour Finale — gentle outward sweep, no crash ───────────
    if (theme.isHourFinale && !ripples.some(r => r.isHour)) {
        ripples.push({
            r: innerRadius,
            a: 1.6,
            isHour: true,
            reflected: false,
            v: baseSize * 0.006,
        });
    }

    // Decay flash (time-based)
    state.coreFlash *= Math.pow(0.96, dt);

    // ── Charge Energy ──────────────────────────────────────────
    const targetCharge = theme.chargePower;
    state.chargeEnergy += (targetCharge - state.chargeEnergy) * 0.08 * dt;

    // ── Ghost Time Label (long-press only) ─────────────────────
    if (state.ghostTimer > 0) {
        state.ghostTimer -= dt;
        state.ghostAlpha = Math.min(0.65, state.ghostTimer / 50);
    } else {
        state.ghostAlpha *= Math.pow(0.92, dt);
    }

    // ── Three-Tier Ring System ────────────────────────────────
    const currentMinute = theme.m;
    const passedRings = currentMinute === 0 ? 0 : currentMinute;

    // Update glow state for all rings (ripple interactions)
    minuteRings.forEach((ring) => {
        let isScanned = false;
        let isHit = false;
        for (let ri = 0; ri < ripples.length; ri++) {
            const rp = ripples[ri];
            const dist = Math.abs(rp.r - ring.r);
            if (rp.isHour && dist < baseSize * 0.035) isScanned = true;
            if (!rp.isHour && dist < baseSize * 0.018) isHit = true;
        }
        if (isScanned) ring.glow = 2.5;
        if (isHit) ring.glow = Math.max(ring.glow, 1.5);
        ring.glow *= Math.pow(0.94, dt);
    });

    // TIER 1: Fill Bands — soft radial glow between landmarks
    // Draws filled arcs between 5-minute boundaries to show elapsed time
    for (let seg = 0; seg < 12; seg++) {
        const segStart = seg * 5;        // minute 0, 5, 10...
        const segEnd = (seg + 1) * 5;    // minute 5, 10, 15...
        const rInner = minuteRings[segStart].r;  // ring index 0 = minute 1
        const rOuter = minuteRings[segEnd - 1].r;

        // How filled is this segment? (0 = empty, 1 = full)
        let fillAmount;
        if (passedRings >= segEnd) {
            fillAmount = 1;
        } else if (passedRings <= segStart) {
            fillAmount = 0;
        } else {
            fillAmount = (passedRings - segStart) / 5;
        }

        // Average glow from ripple hits in this segment
        let segGlow = 0;
        for (let ri = segStart; ri < segEnd; ri++) {
            segGlow = Math.max(segGlow, minuteRings[ri].glow);
        }

        if (fillAmount > 0 || segGlow > 0.1) {
            const fillRadius = rInner + (rOuter - rInner) * fillAmount;
            const grad = ctx.createRadialGradient(cx, cy, rInner, cx, cy, fillAmount > 0 ? fillRadius : rOuter);
            const hueStr = `hsl(${theme.baseHue}, 65%, 55%)`;
            const hueStrFade = `hsla(${theme.baseHue}, 65%, 55%, 0)`;
            const glowStr = `hsla(0, 0%, 100%, ${Math.min(segGlow * 0.3, 0.6)})`;

            if (fillAmount > 0) {
                grad.addColorStop(0, hueStrFade);
                grad.addColorStop(0.3, hueStr);
                grad.addColorStop(0.9, hueStr);
                grad.addColorStop(1, hueStrFade);
            } else {
                grad.addColorStop(0, glowStr);
                grad.addColorStop(1, `hsla(0, 0%, 100%, 0)`);
            }

            ctx.globalAlpha = fillAmount > 0
                ? 0.12 + fillAmount * 0.08 + segGlow * 0.15
                : segGlow * 0.15;
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(cx, cy, fillAmount > 0 ? fillRadius : rOuter, 0, TWO_PI);
            ctx.arc(cx, cy, rInner, 0, TWO_PI, true); // cut out inner
            ctx.fill();
        }
    }

    // TIER 2: 5-Minute Tick Marks with Depth — the countable markers (12 total)
    for (let tick = 1; tick <= 12; tick++) {
        const ringIdx = tick * 5 - 1;
        const ring = minuteRings[ringIdx];
        const minuteNum = tick * 5;
        const hasPassed = minuteNum <= passedRings;
        const isQuarter = minuteNum % 15 === 0;

        let alpha, lineW, color;

        if (isQuarter) {
            alpha = hasPassed ? 0.7 : 0.18;
            lineW = state.isMobile ? 3.0 : 4.0;
            color = hasPassed ? theme.quarter : theme.ring;
        } else {
            alpha = hasPassed ? 0.5 : 0.1;
            lineW = state.isMobile ? 1.8 : 2.2;
            color = hasPassed ? theme.ringLit : theme.ring;
        }

        // Ripple glow boost
        alpha += ring.glow * 0.3;
        if (ring.glow > 1.2) color = "#fff";

        // Idle dims the rings slightly
        alpha *= (1 - idle * 0.4);

        // ── Depth: outer shadow (dark ring slightly outside) ──
        ctx.globalAlpha = Math.min(alpha * 0.25, 0.2);
        ctx.strokeStyle = `hsla(${theme.baseHue}, 30%, 8%, 1)`;
        ctx.lineWidth = lineW + (isQuarter ? 3 : 1.5);
        drawCircle(cx, cy, ring.r + 0.5);
        ctx.stroke();

        // ── Main ring stroke ──
        ctx.globalAlpha = Math.min(alpha, 1);
        ctx.strokeStyle = color;
        ctx.lineWidth = lineW;
        drawCircle(cx, cy, ring.r);
        ctx.stroke();

        // ── Depth: inner highlight (bright thin ring slightly inside) ──
        if (hasPassed || ring.glow > 0.3) {
            ctx.globalAlpha = Math.min(alpha * 0.35, 0.4);
            ctx.strokeStyle = `hsla(${theme.baseHue}, 60%, 85%, 1)`;
            ctx.lineWidth = isQuarter ? 1.0 : 0.5;
            drawCircle(cx, cy, ring.r - lineW * 0.4);
            ctx.stroke();
        }

        // ── Depth: soft glow bloom behind passed quarter walls ──
        if (isQuarter && hasPassed) {
            const glowWidth = baseSize * 0.012;
            const qGrad = ctx.createRadialGradient(
                cx, cy, ring.r - glowWidth,
                cx, cy, ring.r + glowWidth
            );
            qGrad.addColorStop(0, 'transparent');
            qGrad.addColorStop(0.4, `hsla(${(theme.baseHue + 30) % 360}, 80%, 70%, 0.15)`);
            qGrad.addColorStop(0.6, `hsla(${(theme.baseHue + 30) % 360}, 80%, 70%, 0.15)`);
            qGrad.addColorStop(1, 'transparent');
            ctx.globalAlpha = 0.5 + ring.glow * 0.3;
            ctx.fillStyle = qGrad;
            ctx.beginPath();
            ctx.arc(cx, cy, ring.r + glowWidth, 0, TWO_PI);
            ctx.arc(cx, cy, ring.r - glowWidth, 0, TWO_PI, true);
            ctx.fill();
        }
    }

    // Outer boundary ring with depth — the "wall" the agent pushes toward
    // Shadow
    ctx.globalAlpha = 0.04;
    ctx.strokeStyle = `hsla(${theme.baseHue}, 30%, 5%, 1)`;
    ctx.lineWidth = 3;
    drawCircle(cx, cy, maxClockRadius + 1);
    ctx.stroke();
    // Main
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = theme.ring;
    ctx.lineWidth = 1;
    drawCircle(cx, cy, maxClockRadius);
    ctx.stroke();
    // Inner edge highlight
    ctx.globalAlpha = 0.03;
    ctx.strokeStyle = `hsla(${theme.baseHue}, 50%, 80%, 1)`;
    ctx.lineWidth = 0.5;
    drawCircle(cx, cy, maxClockRadius - 1);
    ctx.stroke();

    // ── Quarter Cardinal Ticks (12/3/6/9 outside ring field) ──
    for (let q = 0; q < 4; q++) {
        const angle = (q * Math.PI / 2) - Math.PI / 2;
        const inner = maxClockRadius + baseSize * 0.008;
        const outer = maxClockRadius + baseSize * 0.028;
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = theme.quarter;
        ctx.lineWidth = state.isMobile ? 1.5 : 2;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
        ctx.lineTo(cx + Math.cos(angle) * outer, cy + Math.sin(angle) * outer);
        ctx.stroke();
    }

    // ── Sparks — Collective Seconds Energy ─────────────────────
    // 20 orbiters that collectively tighten, accelerate, and brighten
    // as the minute progresses. They feel the passage of time as a group.
    const minProgress = theme.secFrac / 60; // 0..1 over the minute
    const circEnergy = theme.circadianEnergy; // 0..1, peaks at noon
    const chargeEffect = state.chargeEnergy;

    sparks.forEach((p) => {
        // All sparks drift inward together as the minute progresses
        const outerDist = p.outerOrbit;
        const innerDist = p.innerTarget;
        let targetDist = outerDist - minProgress * (outerDist - innerDist) * 0.7;

        // Charge phase: pull even tighter in final 8 seconds
        if (chargeEffect > 0.01) {
            targetDist *= (1 - chargeEffect * 0.5);
        }

        // Touch scatter
        if (p.scattered > 0.5) {
            p.dist += Math.cos(p.scatterAngle - p.angle) * p.scattered * 0.3 * dt;
            p.angle += Math.sin(p.scatterAngle - p.angle) * p.scattered * 0.003 * dt;
            p.scattered *= Math.pow(0.92, dt);
        }

        p.dist += (targetDist - p.dist) * 0.04 * dt;

        // Speed increases with minute progress + circadian energy; slows when idle
        const idleSpeedDamp = 1 - idle * 0.7;
        const speedMult = (0.4 + circEnergy * 0.8) * (1 + minProgress * 1.5 + chargeEffect * 3) * idleSpeedDamp;
        p.angle += p.baseSpeed * speedMult * dt;

        const px = cx + Math.cos(p.angle) * p.dist;
        const py = cy + Math.sin(p.angle) * p.dist;
        p.trail.push({ x: px, y: py });

        // Trail length: longer at midday, grows slightly with minute progress
        const maxTrail = state.isMobile
            ? Math.floor(5 + circEnergy * 6 + minProgress * 4)
            : Math.floor(6 + circEnergy * 10 + minProgress * 6);
        while (p.trail.length > maxTrail) p.trail.shift();

        // Ring interaction — light up rings when sparks cross them
        const currentRingIdx = minuteRings.findIndex(ring => ring.r > p.dist) - 1;
        if (currentRingIdx >= 0 && currentRingIdx !== p.lastRingCross && p.lastRingCross >= 0) {
            const crossedIdx = Math.min(currentRingIdx, p.lastRingCross);
            if (crossedIdx >= 0 && crossedIdx < 60) {
                minuteRings[crossedIdx].glow = Math.max(minuteRings[crossedIdx].glow, 0.6);
            }
        }
        p.lastRingCross = currentRingIdx;

        // Draw trail — brighter as minute progresses; dimmer when idle
        const distFade = Math.max(0, Math.min(1, (p.dist - 5) / 30));
        const baseAlpha = (0.35 + minProgress * 0.35) * (1 - idle * 0.5);
        for (let ti = 0; ti < p.trail.length; ti++) {
            const t = p.trail[ti];
            const progress = (ti + 1) / p.trail.length;
            const sz = p.size * progress * (0.3 + distFade * 0.7);
            ctx.globalAlpha = progress * baseAlpha * distFade * (0.3 + circEnergy * 0.7);
            ctx.fillStyle = minProgress > 0.85 ? theme.core : theme.spark;
            ctx.beginPath();
            ctx.arc(t.x, t.y, sz, 0, TWO_PI);
            ctx.fill();
        }
    });

    // ── Ripples (safe reverse iteration) ───────────────────────
    for (let i = ripples.length - 1; i >= 0; i--) {
        const r = ripples[i];
        const edgeFade = 1 - r.r / maxScreenDist;

        ctx.globalAlpha = r.a * 0.35 * Math.max(0, edgeFade);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = r.isHour ? 2 : 1.2;
        drawCircle(cx, cy, Math.max(0, r.r));
        ctx.stroke();

        r.r += r.v * dt;

        if (r.isHour) {
            // Hour ripple: sweeps outward past the clock, fading gracefully
            // As it passes rings, they get a brief scan glow (handled above)
            // Gentle core pulse when it first launches
            if (r.r < innerRadius * 1.5 && state.coreFlash < 2) {
                state.coreFlash = 2.0;
            }
            // Gently nudge sparks outward as the wave passes
            if (r.r > innerRadius && r.r < maxClockRadius) {
                sparks.forEach(p => {
                    if (Math.abs(p.dist - r.r) < baseSize * 0.04) {
                        p.scattered = Math.max(p.scattered, baseSize * 0.03);
                        p.scatterAngle = p.angle + Math.PI;
                    }
                });
            }
            // Fade out once past the clock boundary
            if (r.r > maxClockRadius * 1.2) {
                r.a -= 0.025 * dt;
            }
            if (r.a <= 0) ripples.splice(i, 1);
        } else {
            // Minute ripple: unchanged behavior
            if (r.r > maxClockRadius * 1.6) {
                r.a -= 0.04 * dt;
                if (r.a <= 0) ripples.splice(i, 1);
            }
        }
    }

    // ── Touch Ripples (safe reverse iteration) ─────────────────
    for (let i = touchRipples.length - 1; i >= 0; i--) {
        const r = touchRipples[i];
        ctx.globalAlpha = r.a * 0.3;
        ctx.strokeStyle = theme.spark;
        ctx.lineWidth = 1.5;
        drawCircle(r.x, r.y, r.r);
        ctx.stroke();
        r.r += r.v * dt;
        r.a -= 0.015 * dt;
        if (r.a <= 0) touchRipples.splice(i, 1);
    }

    // ── Agent Core — alive, aware, breathing ──────────────────
    const coreSize = baseSize * 0.07;

    // Organic breathing: layered sine waves for imperfect rhythm
    const breathFreq = 0.0015 - idle * 0.0009;
    const breathPrimary = Math.sin(timestamp * breathFreq);
    const breathSecondary = Math.sin(timestamp * breathFreq * 0.37) * 0.3;
    const breathCatch = Math.sin(timestamp * breathFreq * 2.1) * 0.08; // slight catch
    const breathCycle = breathPrimary + breathSecondary + breathCatch;
    const breathAmp = 0.03 + idle * 0.025;
    const breath = 1 + breathCycle * breathAmp - state.chargeEnergy * 0.25;
    const coreRadius = coreSize * breath;

    // Core wander — gentle drift around center, like finding balance
    const wanderX = Math.sin(timestamp * 0.0003) * baseSize * 0.004
                   + Math.sin(timestamp * 0.00071) * baseSize * 0.002;
    const wanderY = Math.cos(timestamp * 0.00025) * baseSize * 0.004
                   + Math.cos(timestamp * 0.00063) * baseSize * 0.002;
    // Wander reduces during charge (focusing) and increases in idle (drifting)
    const wanderScale = (1 - state.chargeEnergy * 0.8) * (1 + idle * 0.5);
    const coreCX = cx + wanderX * wanderScale;
    const coreCY = cy + wanderY * wanderScale;

    // Awareness pulse — reacts to nearby spark proximity
    let awarenessBoost = 0;
    sparks.forEach(p => {
        if (p.dist < innerRadius * 2) {
            awarenessBoost += (1 - p.dist / (innerRadius * 2)) * 0.02;
        }
    });
    awarenessBoost = Math.min(awarenessBoost, 0.15);
    // Also reacts to approaching minute boundary
    const minuteUrgency = minProgress > 0.9 ? (minProgress - 0.9) * 10 : 0; // 0..1 in last 6 sec
    awarenessBoost += minuteUrgency * 0.08;

    // Outer glow halo
    ctx.globalAlpha = 0.15 + state.coreFlash * 0.08 + awarenessBoost;
    const haloGrad = ctx.createRadialGradient(coreCX, coreCY, coreRadius, coreCX, coreCY, coreRadius * 3);
    haloGrad.addColorStop(0, theme.core);
    haloGrad.addColorStop(1, "transparent");
    ctx.fillStyle = haloGrad;
    drawCircle(coreCX, coreCY, coreRadius * 3);
    ctx.fill();

    // Core flash (white burst on minute fire)
    if (state.coreFlash > 0.5) {
        ctx.globalAlpha = Math.min(0.6, state.coreFlash * 0.15);
        const flashGrad = ctx.createRadialGradient(coreCX, coreCY, 0, coreCX, coreCY, coreRadius * 2.5);
        flashGrad.addColorStop(0, "#fff");
        flashGrad.addColorStop(1, "transparent");
        ctx.fillStyle = flashGrad;
        drawCircle(coreCX, coreCY, coreRadius * 2.5);
        ctx.fill();
    }

    // Inner core
    ctx.globalAlpha = 0.95;
    const coreGrad = ctx.createRadialGradient(coreCX, coreCY, 0, coreCX, coreCY, coreRadius * 1.3);
    coreGrad.addColorStop(0, "#fff");
    coreGrad.addColorStop(0.4, theme.core);
    coreGrad.addColorStop(1, "transparent");
    ctx.fillStyle = coreGrad;
    drawCircle(coreCX, coreCY, coreRadius * 1.3);
    ctx.fill();

    // Charge indicator: ring tightens around core
    if (state.chargeEnergy > 0.02) {
        const chargeRadius = coreRadius * (1.8 - state.chargeEnergy * 0.6);
        ctx.globalAlpha = state.chargeEnergy * 0.7;
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1 + state.chargeEnergy * 2;
        drawCircle(coreCX, coreCY, chargeRadius);
        ctx.stroke();
    }

    // ── Hour Marker Dots ───────────────────────────────────────
    // 12 dots around outer edge for hour reading
    const hourDotRadius = maxClockRadius + baseSize * 0.05;
    const currentHour = theme.h % 12;
    for (let hd = 0; hd < 12; hd++) {
        const angle = (hd / 12) * TWO_PI - Math.PI / 2;
        const hx = cx + Math.cos(angle) * hourDotRadius;
        const hy = cy + Math.sin(angle) * hourDotRadius;
        const isCurrentHour = hd === currentHour;
        const isCardinal = hd % 3 === 0;

        const dotSize = isCardinal
            ? (state.isMobile ? 3.5 : 4.5)
            : (state.isMobile ? 1.8 : 2.2);

        ctx.globalAlpha = isCurrentHour ? 0.9 : (isCardinal ? 0.35 : 0.15);
        ctx.fillStyle = isCurrentHour ? "#fff" : theme.quarter;
        ctx.beginPath();
        ctx.arc(hx, hy, dotSize, 0, TWO_PI);
        ctx.fill();

        // Current hour: add glow with AM/PM tint
        if (isCurrentHour) {
            // AM = warm amber glow, PM = cool blue glow
            const ampmColor = theme.isAM
                ? 'hsla(35, 90%, 70%,'   // warm amber
                : 'hsla(220, 70%, 75%,'; // cool blue
            ctx.globalAlpha = 0.25 + Math.sin(timestamp * 0.002) * 0.1;
            const hourGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, dotSize * 5);
            hourGlow.addColorStop(0, ampmColor + ' 0.8)');
            hourGlow.addColorStop(0.5, ampmColor + ' 0.3)');
            hourGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = hourGlow;
            ctx.beginPath();
            ctx.arc(hx, hy, dotSize * 5, 0, TWO_PI);
            ctx.fill();
        }
    }

    // ── Constellation Patterns (#4) ───────────────────────────
    // Sparks periodically form geometric shapes encoding the hour
    // Triangles (3,6,9,12), lines, clusters — subtle and organic
    if (constellationCooldown > 0) {
        constellationCooldown -= dt;
    } else if (Math.random() < 0.0008 * dt) {
        // Trigger a constellation flash
        constellationAlpha = 1.0;
        constellationCooldown = 300; // ~5 seconds between formations
    }

    if (constellationAlpha > 0.02) {
        const hour12 = theme.h % 12 || 12;
        const constellationRadius = baseSize * 0.16;
        // Number of vertices = hour mapped to shapes:
        // 1-2: line, 3: triangle, 4: square, 5: pentagon, etc.
        const vertices = Math.max(2, Math.min(hour12, 12));
        const angleOffset = -Math.PI / 2 + timestamp * 0.0001; // slow rotation

        ctx.globalAlpha = constellationAlpha * 0.25;
        ctx.strokeStyle = theme.quarter;
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        for (let v = 0; v <= vertices; v++) {
            const a = angleOffset + (v / vertices) * TWO_PI;
            const vx = cx + Math.cos(a) * constellationRadius;
            const vy = cy + Math.sin(a) * constellationRadius;
            if (v === 0) ctx.moveTo(vx, vy);
            else ctx.lineTo(vx, vy);
        }
        ctx.stroke();

        // Small dots at vertices
        for (let v = 0; v < vertices; v++) {
            const a = angleOffset + (v / vertices) * TWO_PI;
            const vx = cx + Math.cos(a) * constellationRadius;
            const vy = cy + Math.sin(a) * constellationRadius;
            ctx.globalAlpha = constellationAlpha * 0.5;
            ctx.fillStyle = theme.quarter;
            ctx.beginPath();
            ctx.arc(vx, vy, 2, 0, TWO_PI);
            ctx.fill();
        }

        constellationAlpha *= Math.pow(0.985, dt);
    }

    // ── Time Ghost Label ───────────────────────────────────────
    if (state.ghostAlpha > 0.01) {
        const h12 = theme.h % 12 || 12;
        const mPad = theme.m < 10 ? '0' + theme.m : '' + theme.m;
        const ampm = theme.h < 12 ? 'am' : 'pm';
        const timeStr = `${h12}:${mPad} ${ampm}`;

        // Position just below the hour dots, scaled for screen size
        const labelOffset = state.isMobile ? baseSize * 0.12 : baseSize * 0.10;
        const fontSize = state.isMobile ? baseSize * 0.055 : baseSize * 0.04;

        ctx.save();
        ctx.globalAlpha = Math.min(state.ghostAlpha, 0.6);
        ctx.fillStyle = "#fff";
        ctx.font = `200 ${fontSize}px system-ui, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(timeStr, cx, cy + maxClockRadius + labelOffset);
        ctx.restore();
    }

    // ── Second Progress Arc ────────────────────────────────────
    // Visible arc on the active ring with a leading dot cursor
    if (passedRings < 60) {
        const activeRing = minuteRings[passedRings];
        if (activeRing) {
            const secProgress = theme.secFrac / 60;
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + secProgress * TWO_PI;
            const arcRadius = activeRing.r;

            // The arc itself
            ctx.globalAlpha = 0.3 + state.chargeEnergy * 0.4;
            ctx.strokeStyle = theme.core;
            ctx.lineWidth = state.isMobile ? 2.0 : 2.8;
            ctx.beginPath();
            ctx.arc(cx, cy, arcRadius, startAngle, endAngle);
            ctx.stroke();

            // Leading dot at the arc's head
            const dotX = cx + Math.cos(endAngle) * arcRadius;
            const dotY = cy + Math.sin(endAngle) * arcRadius;
            const dotSize = state.isMobile ? 3 : 4;

            // Dot glow
            ctx.globalAlpha = 0.25 + state.chargeEnergy * 0.3;
            const dotGlow = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, dotSize * 3);
            dotGlow.addColorStop(0, theme.core);
            dotGlow.addColorStop(1, "transparent");
            ctx.fillStyle = dotGlow;
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotSize * 3, 0, TWO_PI);
            ctx.fill();

            // Dot core
            ctx.globalAlpha = 0.8 + state.chargeEnergy * 0.2;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotSize, 0, TWO_PI);
            ctx.fill();
        }
    }

    // Reset alpha
    ctx.globalAlpha = 1;

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

// ── Chat Integration ──────────────────────────────────────────────
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
const chatResponse = document.getElementById('chat-response');
const zenStatus = document.getElementById('zen-status');
const statusLabel = zenStatus.querySelector('.label');

let responseTimeout = null;
let statusTimeout = null;
let isWaiting = false;
let isOnline = false;
let alwaysListening = false;

function setStatus(status, label, persist = false) {
    zenStatus.classList.remove('online', 'offline', 'checking', 'listening', 'waking');
    zenStatus.classList.add('visible', status);
    statusLabel.textContent = label;

    // Auto-hide status after it's been shown (unless persistent or in listening mode)
    clearTimeout(statusTimeout);
    if (!persist && !alwaysListening && status === 'online') {
        statusTimeout = setTimeout(() => {
            zenStatus.classList.remove('visible');
        }, 5000);
    }
}

// Update status when in always-listening mode
function updateListeningStatus() {
    if (alwaysListening) {
        setStatus('listening', 'Listening for "Hey Zen"...', true);
    }
}

async function checkConnection(attempt = 1) {
    const maxAttempts = 3;
    setStatus('checking', attempt > 1 ? `Waking Zen (${attempt}/${maxAttempts})...` : 'Connecting...');

    try {
        // Longer timeout for Railway cold starts
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 15000); // 15 second timeout

        const res = await fetch('/api/health', {
            method: 'GET',
            cache: 'no-store',
            signal: controller.signal
        });
        clearTimeout(timeout);

        if (res.ok) {
            const data = await res.json();
            isOnline = true;
            setStatus('online', 'Zen is awake');

            // Show a greeting from Zen
            setTimeout(() => {
                showGreeting();
            }, 800);
        } else {
            throw new Error('Health check failed');
        }
    } catch (error) {
        console.error(`Connection check failed (attempt ${attempt}):`, error);

        // Retry for cold starts
        if (attempt < maxAttempts) {
            setTimeout(() => checkConnection(attempt + 1), 2000);
        } else {
            isOnline = false;
            setStatus('offline', 'Zen is sleeping');
        }
    }
}

async function showGreeting() {
    // Get a greeting from Zen
    try {
        const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: 'Say a brief, warm greeting (one sentence max). Mention the current time naturally.',
                clientTime: new Date().toISOString()
            })
        });

        if (res.ok) {
            const data = await res.json();
            chatResponse.textContent = data.response;
            chatResponse.classList.add('visible');
            state.coreFlash = 2.5;

            // Speak the greeting
            speakResponse(data.response);

            clearTimeout(responseTimeout);
            responseTimeout = setTimeout(() => {
                chatResponse.classList.remove('visible');
            }, 8000);
        }
    } catch (error) {
        // Silent fail for greeting - not critical
        console.log('Greeting skipped:', error);
    }
}

async function sendMessage(spokenMessage = null) {
    // Only use spokenMessage if it's actually a string (not an Event object from click handlers)
    const message = (typeof spokenMessage === 'string' && spokenMessage) ? spokenMessage : chatInput.value.trim();
    if (!message || isWaiting) return;

    isWaiting = true;
    chatSend.disabled = true;
    chatInput.disabled = true;

    // Show thinking state
    chatResponse.textContent = '...';
    chatResponse.classList.add('visible', 'thinking');

    // Show "Waking Zen" status for slow responses
    const wakingTimeout = setTimeout(() => {
        setStatus('waking', 'Waking Zen...', true);
    }, 2000);

    // Check if this is a reminder request (in parallel with chat)
    checkForReminder(message);

    try {
        const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message, clientTime: new Date().toISOString() })
        });

        clearTimeout(wakingTimeout);

        if (!res.ok) {
            throw new Error(`Server error: ${res.status}`);
        }

        const data = await res.json();
        const responseText = data.response || 'No response received.';

        // Display response
        chatResponse.classList.remove('thinking');
        chatResponse.textContent = responseText;

        // Speak the response
        speakResponse(responseText);

        // Clear input on success
        chatInput.value = '';

        // Trigger core flash to show Zen is "speaking"
        state.coreFlash = Math.max(state.coreFlash || 0, 2.0);

        // Update status
        isOnline = true;
        if (alwaysListening) {
            updateListeningStatus();
        } else {
            setStatus('online', 'Zen is awake');
        }

        // Auto-hide response after 12 seconds
        clearTimeout(responseTimeout);
        responseTimeout = setTimeout(() => {
            chatResponse.classList.remove('visible');
        }, 12000);

    } catch (error) {
        clearTimeout(wakingTimeout);
        console.error('Chat error:', error);
        chatResponse.classList.remove('thinking');
        chatResponse.textContent = 'Unable to reach Zen. Please check your connection.';
        isOnline = false;
        setStatus('offline', 'Zen is sleeping');

        clearTimeout(responseTimeout);
        responseTimeout = setTimeout(() => {
            chatResponse.classList.remove('visible');
        }, 5000);
    } finally {
        isWaiting = false;
        chatSend.disabled = false;
        chatInput.disabled = false;
        if (!alwaysListening) {
            chatInput.focus();
        }
    }
}

// Event listeners
chatSend.addEventListener('click', () => sendMessage());
chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

// Clicking on response hides it
chatResponse.addEventListener('click', () => {
    chatResponse.classList.remove('visible');
    clearTimeout(responseTimeout);
});

// ── Voice Output (Text-to-Speech) ────────────────────────────────
const synth = window.speechSynthesis;
let zenVoice = null;
let voiceEnabled = true;
let voicesLoaded = false;

// Find a calm, pleasant voice
function loadVoices() {
    if (!synth) return;

    const voices = synth.getVoices();
    console.log('Available voices:', voices.length);

    if (voices.length === 0) {
        // Voices not loaded yet - will retry on voiceschanged
        return;
    }

    voicesLoaded = true;

    // Prefer: Samantha (Mac), Google UK English Female, or any female en voice
    zenVoice = voices.find(v => v.name.includes('Samantha')) ||
               voices.find(v => v.name.includes('Google UK English Female')) ||
               voices.find(v => v.name.toLowerCase().includes('female') && v.lang.startsWith('en')) ||
               voices.find(v => v.lang.startsWith('en')) ||
               voices[0]; // Fallback to first available voice

    console.log('Selected voice:', zenVoice?.name || 'default');
}

if (synth) {
    loadVoices();
    synth.onvoiceschanged = loadVoices;

    // Some browsers need a delay to load voices
    setTimeout(loadVoices, 100);
    setTimeout(loadVoices, 500);
    setTimeout(loadVoices, 1000);
}

let currentKeepAlive = null;

function speakResponse(text) {
    if (!synth || !voiceEnabled || !text) {
        console.log('TTS skipped:', !synth ? 'no synth' : !voiceEnabled ? 'disabled' : 'no text');
        return;
    }

    console.log('Speaking:', text.substring(0, 50) + '...');

    // Clear any previous keep-alive interval
    if (currentKeepAlive) {
        clearInterval(currentKeepAlive);
        currentKeepAlive = null;
    }

    // Cancel any ongoing speech
    synth.cancel();

    // Try to load voices if not loaded yet
    if (!voicesLoaded) {
        loadVoices();
    }

    const utterance = new SpeechSynthesisUtterance(text);

    if (zenVoice) {
        utterance.voice = zenVoice;
    }

    utterance.rate = 0.92;  // Slightly slower for zen feel
    utterance.pitch = 1.0;
    utterance.volume = 0.85;

    utterance.onstart = () => console.log('TTS started');
    utterance.onend = () => {
        console.log('TTS ended');
        if (currentKeepAlive) {
            clearInterval(currentKeepAlive);
            currentKeepAlive = null;
        }
    };
    utterance.onerror = (e) => {
        console.error('TTS error:', e.error);
        if (currentKeepAlive) {
            clearInterval(currentKeepAlive);
            currentKeepAlive = null;
        }
    };

    // Mobile Safari workaround: need to speak immediately after user gesture
    if (synth.paused) {
        synth.resume();
    }

    synth.speak(utterance);

    // Chrome bug workaround: speech synthesis stops after ~15 seconds
    // Resume more frequently (every 5 seconds) to prevent cutoff
    // Only pause/resume if actually speaking to avoid stutters
    currentKeepAlive = setInterval(() => {
        if (synth.speaking && !synth.paused) {
            synth.pause();
            synth.resume();
        } else if (!synth.speaking) {
            clearInterval(currentKeepAlive);
            currentKeepAlive = null;
        }
    }, 5000);
}

// ── Voice Input (Web Speech API) with Continuous Listening ───────
const voiceBtn = document.getElementById('voice-btn');
let recognition = null;
let isListening = false;
let longPressVoiceTimer = null;

// Wake words that trigger Zen
const WAKE_WORDS = ['hey zen', 'okay zen', 'ok zen', 'hey zen,', 'zen,', 'zen '];

function extractCommand(transcript) {
    const lower = transcript.toLowerCase().trim();

    // Check for wake words and extract the command after them
    for (const wake of WAKE_WORDS) {
        const idx = lower.indexOf(wake);
        if (idx !== -1) {
            const command = transcript.slice(idx + wake.length).trim();
            return command || null;
        }
    }

    // If just "zen" at the very start, take the rest as command
    if (lower.startsWith('zen ') || lower.startsWith('zen,')) {
        return transcript.slice(4).trim();
    }

    return null;
}

// Check if Speech Recognition is supported
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

if (SpeechRecognition) {
    recognition = new SpeechRecognition();
    recognition.interimResults = true;
    recognition.lang = 'en-US';

    recognition.onstart = () => {
        isListening = true;
        voiceBtn.classList.add('listening');
        if (alwaysListening) {
            chatInput.placeholder = 'Say "Hey Zen" + command...';
        } else {
            chatInput.placeholder = 'Listening...';
        }
    };

    recognition.onend = () => {
        isListening = false;
        voiceBtn.classList.remove('listening');

        // In always-listening mode, restart recognition after a short pause
        if (alwaysListening && !isWaiting) {
            setTimeout(() => {
                if (alwaysListening && !isListening) {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.log('Recognition restart failed:', e);
                    }
                }
            }, 300);
            chatInput.placeholder = 'Say "Hey Zen"...';
        } else {
            chatInput.placeholder = 'Ask Zen anything...';
        }
    };

    recognition.onresult = (event) => {
        let finalTranscript = '';
        let interimTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;
            if (event.results[i].isFinal) {
                finalTranscript += transcript;
            } else {
                interimTranscript += transcript;
            }
        }

        if (alwaysListening) {
            // In always-listening mode, check for wake word
            const fullText = interimTranscript || finalTranscript;
            chatInput.value = fullText;

            if (finalTranscript) {
                const command = extractCommand(finalTranscript);
                if (command && command.length > 2) {
                    console.log('Wake word detected! Command:', command);
                    state.coreFlash = 2.0; // Visual feedback
                    chatInput.value = command;
                    sendMessage(command);
                } else if (command === null) {
                    // No wake word found - clear and keep listening
                    chatInput.value = '';
                }
            }
        } else {
            // Push-to-talk mode: send everything
            if (interimTranscript) {
                chatInput.value = interimTranscript;
            }

            if (finalTranscript) {
                chatInput.value = finalTranscript;
                sendMessage();
            }
        }
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);

        // Don't stop always-listening on transient errors
        if (event.error === 'no-speech' || event.error === 'aborted') {
            if (alwaysListening) {
                // Just restart
                return;
            }
        }

        isListening = false;
        voiceBtn.classList.remove('listening');

        if (!alwaysListening) {
            chatInput.placeholder = 'Ask Zen anything...';
        }

        if (event.error === 'not-allowed') {
            chatResponse.textContent = 'Microphone access denied. Please enable microphone for voice commands.';
            chatResponse.classList.add('visible');
            alwaysListening = false;
            voiceBtn.classList.remove('always-on');
            setTimeout(() => chatResponse.classList.remove('visible'), 5000);
        }
    };

    // Toggle always-listening mode on long press
    function enableAlwaysListening() {
        alwaysListening = true;
        voiceBtn.classList.add('always-on');
        recognition.continuous = true;
        setStatus('listening', 'Listening for "Hey Zen"...', true);
        chatInput.placeholder = 'Say "Hey Zen"...';

        // Start listening
        if (!isListening) {
            try {
                recognition.start();
            } catch (e) {
                console.log('Recognition start failed:', e);
            }
        }

        // Announce the mode
        speakResponse('Always listening mode enabled. Say "Hey Zen" followed by your command.');
    }

    function disableAlwaysListening() {
        alwaysListening = false;
        voiceBtn.classList.remove('always-on');
        recognition.continuous = false;

        if (isListening) {
            recognition.stop();
        }

        chatInput.placeholder = 'Ask Zen anything...';
        setStatus('online', 'Zen is awake');
    }

    // Short press: push-to-talk OR toggle off always-listening
    // Long press: enable always-listening
    voiceBtn.addEventListener('pointerdown', (e) => {
        if (isWaiting) return;

        longPressVoiceTimer = setTimeout(() => {
            longPressVoiceTimer = null;
            if (!alwaysListening) {
                enableAlwaysListening();
            }
        }, 800);
    });

    voiceBtn.addEventListener('pointerup', () => {
        if (longPressVoiceTimer) {
            clearTimeout(longPressVoiceTimer);
            longPressVoiceTimer = null;

            // Short press action
            if (alwaysListening) {
                disableAlwaysListening();
            } else if (isListening) {
                recognition.stop();
            } else {
                recognition.continuous = false;
                recognition.start();
            }
        }
    });

    voiceBtn.addEventListener('pointercancel', () => {
        if (longPressVoiceTimer) {
            clearTimeout(longPressVoiceTimer);
            longPressVoiceTimer = null;
        }
    });

    voiceBtn.addEventListener('pointerleave', () => {
        if (longPressVoiceTimer) {
            clearTimeout(longPressVoiceTimer);
            longPressVoiceTimer = null;
        }
    });

} else {
    // Speech Recognition not supported
    voiceBtn.disabled = true;
    voiceBtn.title = 'Voice input not supported in this browser';
}

// ── Reminders System (with recurring + pomodoro support) ─────────
let reminders = JSON.parse(localStorage.getItem('zenReminders') || '[]');
let notificationPermissionRequested = false;
let ttsUnlocked = false;

// Request notification permission on first user interaction (required for mobile)
async function requestNotificationPermission() {
    if (notificationPermissionRequested) return;
    notificationPermissionRequested = true;

    if ('Notification' in window && Notification.permission === 'default') {
        console.log('Requesting notification permission...');
        const permission = await Notification.requestPermission();
        console.log('Notification permission:', permission);

        if (permission === 'granted') {
            // Test notification to confirm it works
            setTimeout(() => {
                new Notification('Zen Sanctuary', {
                    body: 'Notifications enabled! I can now remind you.',
                    tag: 'zen-test-notification'
                });
            }, 1000);
        }
    }
}

// Unlock TTS on first user interaction (required for mobile)
function unlockTTS() {
    if (ttsUnlocked || !synth) return;

    // Create a silent utterance to unlock TTS
    const unlock = new SpeechSynthesisUtterance('');
    unlock.volume = 0;
    synth.speak(unlock);
    ttsUnlocked = true;
    console.log('TTS unlocked');
}

// First interaction handler - unlock everything
let hasInteracted = false;
function onFirstInteraction() {
    if (hasInteracted) return;
    hasInteracted = true;

    console.log('First interaction - unlocking features');
    requestNotificationPermission();
    unlockTTS();

    // Remove listeners after first interaction
    document.removeEventListener('click', onFirstInteraction);
    document.removeEventListener('touchstart', onFirstInteraction);
}

document.addEventListener('click', onFirstInteraction);
document.addEventListener('touchstart', onFirstInteraction);

function saveReminders() {
    localStorage.setItem('zenReminders', JSON.stringify(reminders));
}

function addReminder(task, minutesFromNow, recurring = false, intervalMinutes = 0) {
    const reminder = {
        id: Date.now(),
        task,
        triggerAt: Date.now() + (minutesFromNow * 60 * 1000),
        notified: false,
        recurring,
        intervalMinutes
    };
    reminders.push(reminder);
    saveReminders();
    return reminder;
}

function listReminders() {
    const active = reminders.filter(r => !r.notified);
    if (active.length === 0) {
        return "No active reminders.";
    }
    return active.map(r => {
        const mins = Math.round((r.triggerAt - Date.now()) / 60000);
        const recurText = r.recurring ? ' (recurring)' : '';
        return `• ${r.task} - in ${mins} min${recurText}`;
    }).join('\n');
}

function cancelReminder(keyword) {
    const before = reminders.length;
    reminders = reminders.filter(r => !r.task.toLowerCase().includes(keyword.toLowerCase()));
    saveReminders();
    return reminders.length < before;
}

function triggerReminder(r) {
    console.log('Triggering reminder:', r.task);

    const reminderText = `Reminder: ${r.task}`;

    // Try browser notification first
    let notificationShown = false;
    if ('Notification' in window) {
        console.log('Notification permission:', Notification.permission);

        if (Notification.permission === 'granted') {
            try {
                const notification = new Notification('Zen Reminder', {
                    body: r.task,
                    icon: '/favicon.ico',
                    tag: 'zen-reminder-' + r.id,
                    requireInteraction: true,
                    vibrate: [200, 100, 200]
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };

                notificationShown = true;
                console.log('Browser notification sent');
            } catch (e) {
                console.error('Notification failed:', e);
            }
        } else if (Notification.permission === 'default') {
            // Try to request permission now
            Notification.requestPermission().then(perm => {
                if (perm === 'granted') {
                    new Notification('Zen Reminder', { body: r.task });
                }
            });
        }
    }

    // Always show in chat UI (works regardless of notification permission)
    chatResponse.textContent = reminderText;
    chatResponse.classList.add('visible');

    // Flash the core dramatically
    state.coreFlash = 4.0;

    // Play a tone/beep if available (fallback audio alert)
    try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = 440; // A4 note
        oscillator.type = 'sine';
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.5);
        console.log('Audio alert played');
    } catch (e) {
        console.log('Audio alert failed:', e);
    }

    // Speak the reminder (TTS)
    speakResponse(reminderText);

    // Keep visible longer for reminders
    clearTimeout(responseTimeout);
    responseTimeout = setTimeout(() => {
        chatResponse.classList.remove('visible');
    }, 15000);

    console.log('Reminder triggered successfully');
}

function checkReminders() {
    const now = Date.now();
    let updated = false;

    reminders.forEach(r => {
        if (!r.notified && now >= r.triggerAt) {
            updated = true;

            // Trigger the reminder with all alerts
            triggerReminder(r);

            // Handle recurring reminders
            if (r.recurring && r.intervalMinutes > 0) {
                r.triggerAt = now + (r.intervalMinutes * 60 * 1000);
                console.log('Recurring reminder rescheduled for', new Date(r.triggerAt));
                // Don't mark as notified - let it fire again
            } else {
                r.notified = true;
            }
        }
    });

    // Clean up old non-recurring notified reminders
    const oneHourAgo = now - 3600000;
    reminders = reminders.filter(r => r.recurring || !r.notified || r.triggerAt > oneHourAgo);

    if (updated) saveReminders();
}

// Check reminders every 5 seconds (faster for better accuracy)
setInterval(checkReminders, 5000);

// Parse potential reminder from message
async function checkForReminder(message) {
    const lowerMsg = message.toLowerCase();

    // Handle special commands locally
    if (lowerMsg.includes('what reminder') || lowerMsg.includes('list reminder') || lowerMsg.includes('my reminder')) {
        const list = listReminders();
        setTimeout(() => {
            chatResponse.textContent = list;
            chatResponse.classList.add('visible');
            speakResponse(list.split('\n')[0]); // Speak first one
        }, 500);
        return null;
    }

    if (lowerMsg.includes('cancel') && lowerMsg.includes('reminder')) {
        // Try to extract what to cancel
        const match = lowerMsg.match(/cancel.*?reminder.*?(?:for|about)?\s*(.+)/i);
        if (match) {
            const keyword = match[1].trim();
            if (cancelReminder(keyword)) {
                setTimeout(() => {
                    chatResponse.textContent = `Cancelled reminder for "${keyword}".`;
                    chatResponse.classList.add('visible');
                }, 500);
            }
        }
        return null;
    }

    // Keywords that trigger reminder parsing
    const reminderKeywords = ['remind', 'reminder', 'alert', 'notify', 'pomodoro', 'focus', 'timer', 'every', 'at \\d'];
    const hasKeyword = reminderKeywords.some(k => new RegExp(k, 'i').test(message));

    if (!hasKeyword) return null;

    try {
        const res = await fetch('/api/parse-reminder', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message })
        });

        if (res.ok) {
            const data = await res.json();
            if (data.isReminder && data.task && data.minutesFromNow > 0) {
                return addReminder(data.task, data.minutesFromNow, data.recurring, data.intervalMinutes);
            }
        }
    } catch (e) {
        console.log('Reminder parse failed:', e);
    }

    return null;
}

// ── Daily Briefing ───────────────────────────────────────────────
async function showDailyBriefing() {
    try {
        // Get weather first
        const weatherRes = await fetch('/api/weather');
        let weatherInfo = '';
        if (weatherRes.ok) {
            const w = await weatherRes.json();
            weatherInfo = `Weather: ${w.temp}°F, ${w.desc}.`;
        }

        // Get active reminders
        const activeReminders = reminders.filter(r => !r.notified);
        const reminderInfo = activeReminders.length > 0
            ? `You have ${activeReminders.length} reminder${activeReminders.length > 1 ? 's' : ''} set.`
            : 'No reminders set.';

        // Ask Zen for a briefing
        const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: `Give me a brief morning briefing. ${weatherInfo} ${reminderInfo} Be warm and encouraging for the day ahead.`,
                clientTime: new Date().toISOString()
            })
        });

        if (res.ok) {
            const data = await res.json();
            chatResponse.textContent = data.response;
            chatResponse.classList.add('visible');
            speakResponse(data.response);
            state.coreFlash = 2.5;

            clearTimeout(responseTimeout);
            responseTimeout = setTimeout(() => {
                chatResponse.classList.remove('visible');
            }, 15000);
        }
    } catch (e) {
        console.log('Briefing failed:', e);
    }
}

// Check connection on page load
setTimeout(checkConnection, 1000);

})();
</script>
</body>
</html>
