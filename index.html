<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Zen Sanctuary - The Reset</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        body { display: flex; align-items: center; justify-content: center; }
        canvas {
            display: block;
            width: 100vw;
            height: 100dvh;
            touch-action: none;
        }
        noscript {
            color: #aaa; font-family: sans-serif; text-align: center;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <canvas id="zenCanvas" role="img" aria-label="Zen Sanctuary: an ambient animated clock"></canvas>
    <noscript>Zen Sanctuary requires JavaScript to display the ambient clock.</noscript>

<script>
(() => {
"use strict";

// ── State ──────────────────────────────────────────────────────────
const canvas = document.getElementById('zenCanvas');
const ctx = canvas.getContext('2d');
const TWO_PI = Math.PI * 2;

const state = {
    w: 0, h: 0, cx: 0, cy: 0, dpr: 1,
    baseSize: 0,
    maxClockRadius: 0,
    innerRadius: 0,
    lastMin: -1,
    lastSec: -1,
    coreFlash: 0,
    ghostAlpha: 0,
    ghostTimer: 0,
    chargeEnergy: 0,
    lastFrameTime: 0,
    isMobile: false,
};

let minuteRings = [];
let sparks = [];
let ripples = [];
let touchRipples = [];

// ── Resize ─────────────────────────────────────────────────────────
function resize() {
    state.dpr = Math.min(window.devicePixelRatio || 1, 2);
    state.w = window.innerWidth;
    state.h = window.innerHeight;
    state.cx = state.w / 2;
    state.cy = state.h / 2;
    state.isMobile = state.w < 768;
    canvas.width = state.w * state.dpr;
    canvas.height = state.h * state.dpr;
    ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
    state.baseSize = Math.min(state.w, state.h);
    state.innerRadius = state.baseSize * 0.08;
    state.maxClockRadius = state.baseSize * (state.isMobile ? 0.42 : 0.40);

    // Rebuild rings preserving glow state
    const oldGlows = minuteRings.map(r => r.glow);
    minuteRings = [];
    for (let i = 1; i <= 60; i++) {
        const t = i / 60;
        const r = state.innerRadius + t * (state.maxClockRadius - state.innerRadius);
        minuteRings.push({ r, glow: oldGlows[i - 1] || 0 });
    }

    // Rebuild sparks preserving orbital state
    const sparkCount = state.isMobile ? 20 : 30;
    while (sparks.length < sparkCount) {
        sparks.push(createSpark());
    }
    sparks.length = sparkCount;
    sparks.forEach(p => { p.orbitRadius = state.baseSize * 0.22; });
}

function createSpark() {
    return {
        angle: Math.random() * TWO_PI,
        dist: 0,
        orbitRadius: state.baseSize * 0.22,
        size: Math.random() * 1.5 + 0.8,
        speed: (Math.random() * 0.008 + 0.004) * (Math.random() > 0.5 ? 1 : -1),
        trail: [],
    };
}

let resizeTimer;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resize, 100);
});
resize();

// ── Interaction ────────────────────────────────────────────────────
function addTouchRipple(x, y) {
    touchRipples.push({ x, y, r: 5, a: 1.2, v: state.baseSize * 0.004 });
}

canvas.addEventListener('pointerdown', (e) => {
    addTouchRipple(e.clientX, e.clientY);
});

// ── Theme ──────────────────────────────────────────────────────────
function getChronoTheme() {
    const now = new Date();
    const h = now.getHours();
    const m = now.getMinutes();
    const s = now.getSeconds();
    const ms = now.getMilliseconds();
    const secFrac = s + ms / 1000;
    const dayProgress = (h + m / 60 + s / 3600) / 24;

    // Circadian: brighter midday, darker at night
    const circadianLume = 5 + Math.sin(dayProgress * Math.PI) * 12;
    const baseHue = (h * 15 + (m / 60) * 15) % 360;

    // Charge cycle: agent builds energy during last 8 seconds of each minute
    const chargeStart = 52;
    const isCharging = s >= chargeStart;
    const chargePower = isCharging ? (secFrac - chargeStart) / (60 - chargeStart) : 0;
    const isHourFinale = m === 59 && s >= 52;

    return {
        baseHue,
        circadianLume,
        core:  `hsl(${baseHue}, 90%, 75%)`,
        ring:  `hsl(${baseHue}, 55%, 45%)`,
        ringLit: `hsl(${baseHue}, 70%, 60%)`,
        bg:    `hsl(${baseHue}, 35%, ${circadianLume}%)`,
        glow:  `hsl(${baseHue}, 50%, ${circadianLume + 12}%)`,
        spark: `hsl(${baseHue}, 100%, 90%)`,
        quarter: `hsl(${(baseHue + 30) % 360}, 80%, 75%)`,
        chargePower, isCharging, isHourFinale,
        h, m, s, ms, secFrac,
    };
}

// ── Drawing Helpers ────────────────────────────────────────────────
function drawCircle(x, y, radius) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, TWO_PI);
}

// ── Main Loop ──────────────────────────────────────────────────────
function loop(timestamp) {
    if (!state.lastFrameTime) state.lastFrameTime = timestamp;
    const dt = Math.min((timestamp - state.lastFrameTime) / 16.667, 3);
    state.lastFrameTime = timestamp;

    const theme = getChronoTheme();
    const { cx, cy, w, h, baseSize, maxClockRadius, innerRadius } = state;
    const maxScreenDist = Math.sqrt(cx * cx + cy * cy);

    // ── Background ─────────────────────────────────────────────
    if (state.coreFlash > 4.5) {
        ctx.fillStyle = "#fff";
    } else {
        const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxScreenDist);
        bgGrad.addColorStop(0, theme.glow);
        bgGrad.addColorStop(1, theme.bg);
        ctx.fillStyle = bgGrad;
    }
    ctx.globalAlpha = 1;
    ctx.fillRect(0, 0, w, h);

    // ── Minute Change: Agent fires a ring ──────────────────────
    if (theme.m !== state.lastMin && state.lastMin !== -1) {
        state.coreFlash = 3.0;
        ripples.push({
            r: innerRadius,
            a: 1.8,
            isHour: false,
            v: baseSize * 0.004,
        });
    }
    state.lastMin = theme.m;

    // ── Hour Finale Scan ───────────────────────────────────────
    if (theme.isHourFinale && !ripples.some(r => r.isHour)) {
        ripples.push({
            r: innerRadius,
            a: 2.5,
            isHour: true,
            reflected: false,
            v: maxScreenDist / 100,
        });
    }

    // Decay flash (time-based)
    state.coreFlash *= Math.pow(0.96, dt);

    // ── Charge Energy ──────────────────────────────────────────
    const targetCharge = theme.chargePower;
    state.chargeEnergy += (targetCharge - state.chargeEnergy) * 0.08 * dt;

    // ── Ghost Time Label trigger ───────────────────────────────
    const rippleHitGhost = ripples.some(r =>
        Math.abs(r.r - maxClockRadius) < baseSize * 0.025
    );
    if (rippleHitGhost) state.ghostTimer = 500;
    if (state.ghostTimer > 0) {
        state.ghostTimer -= dt;
        state.ghostAlpha = Math.min(0.65, state.ghostTimer / 50);
    } else {
        state.ghostAlpha *= Math.pow(0.92, dt);
    }

    // ── Three-Tier Ring System ────────────────────────────────
    const currentMinute = theme.m;
    const passedRings = currentMinute === 0 ? 0 : currentMinute;

    // Update glow state for all rings (ripple interactions)
    minuteRings.forEach((ring) => {
        let isScanned = false;
        let isHit = false;
        for (let ri = 0; ri < ripples.length; ri++) {
            const rp = ripples[ri];
            const dist = Math.abs(rp.r - ring.r);
            if (rp.isHour && dist < baseSize * 0.035) isScanned = true;
            if (!rp.isHour && dist < baseSize * 0.018) isHit = true;
        }
        if (isScanned) ring.glow = 2.5;
        if (isHit) ring.glow = Math.max(ring.glow, 1.5);
        ring.glow *= Math.pow(0.94, dt);
    });

    // TIER 1: Fill Bands — soft radial glow between landmarks
    // Draws filled arcs between 5-minute boundaries to show elapsed time
    for (let seg = 0; seg < 12; seg++) {
        const segStart = seg * 5;        // minute 0, 5, 10...
        const segEnd = (seg + 1) * 5;    // minute 5, 10, 15...
        const rInner = minuteRings[segStart].r;  // ring index 0 = minute 1
        const rOuter = minuteRings[segEnd - 1].r;

        // How filled is this segment? (0 = empty, 1 = full)
        let fillAmount;
        if (passedRings >= segEnd) {
            fillAmount = 1;
        } else if (passedRings <= segStart) {
            fillAmount = 0;
        } else {
            fillAmount = (passedRings - segStart) / 5;
        }

        // Average glow from ripple hits in this segment
        let segGlow = 0;
        for (let ri = segStart; ri < segEnd; ri++) {
            segGlow = Math.max(segGlow, minuteRings[ri].glow);
        }

        if (fillAmount > 0 || segGlow > 0.1) {
            const fillRadius = rInner + (rOuter - rInner) * fillAmount;
            const grad = ctx.createRadialGradient(cx, cy, rInner, cx, cy, fillAmount > 0 ? fillRadius : rOuter);
            const hueStr = `hsl(${theme.baseHue}, 65%, 55%)`;
            const hueStrFade = `hsla(${theme.baseHue}, 65%, 55%, 0)`;
            const glowStr = `hsla(0, 0%, 100%, ${Math.min(segGlow * 0.3, 0.6)})`;

            if (fillAmount > 0) {
                grad.addColorStop(0, hueStrFade);
                grad.addColorStop(0.3, hueStr);
                grad.addColorStop(0.9, hueStr);
                grad.addColorStop(1, hueStrFade);
            } else {
                grad.addColorStop(0, glowStr);
                grad.addColorStop(1, `hsla(0, 0%, 100%, 0)`);
            }

            ctx.globalAlpha = fillAmount > 0
                ? 0.12 + fillAmount * 0.08 + segGlow * 0.15
                : segGlow * 0.15;
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(cx, cy, fillAmount > 0 ? fillRadius : rOuter, 0, TWO_PI);
            ctx.arc(cx, cy, rInner, 0, TWO_PI, true); // cut out inner
            ctx.fill();
        }
    }

    // TIER 2: 5-Minute Tick Marks — the countable markers (12 total)
    for (let tick = 1; tick <= 12; tick++) {
        const ringIdx = tick * 5 - 1; // ring indices: 4, 9, 14, 19... (minutes 5, 10, 15...)
        const ring = minuteRings[ringIdx];
        const minuteNum = tick * 5;
        const hasPassed = minuteNum <= passedRings;
        const isQuarter = minuteNum % 15 === 0;

        let alpha, lineW, color;

        if (isQuarter) {
            // TIER 3: Quarter Walls — 15, 30, 45, 60
            alpha = hasPassed ? 0.7 : 0.18;
            lineW = state.isMobile ? 3.0 : 4.0;
            color = hasPassed ? theme.quarter : theme.ring;
        } else {
            // Regular 5-min tick
            alpha = hasPassed ? 0.5 : 0.1;
            lineW = state.isMobile ? 1.8 : 2.2;
            color = hasPassed ? theme.ringLit : theme.ring;
        }

        // Ripple glow boost
        alpha += ring.glow * 0.3;
        if (ring.glow > 1.2) color = "#fff";

        ctx.globalAlpha = Math.min(alpha, 1);
        ctx.strokeStyle = color;
        ctx.lineWidth = lineW;
        drawCircle(cx, cy, ring.r);
        ctx.stroke();
    }

    // Outer boundary ring — the "wall" the agent pushes toward
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = theme.ring;
    ctx.lineWidth = 1;
    drawCircle(cx, cy, maxClockRadius);
    ctx.stroke();

    // ── Quarter Cardinal Ticks (12/3/6/9 outside ring field) ──
    for (let q = 0; q < 4; q++) {
        const angle = (q * Math.PI / 2) - Math.PI / 2;
        const inner = maxClockRadius + baseSize * 0.008;
        const outer = maxClockRadius + baseSize * 0.028;
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = theme.quarter;
        ctx.lineWidth = state.isMobile ? 1.5 : 2;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
        ctx.lineTo(cx + Math.cos(angle) * outer, cy + Math.sin(angle) * outer);
        ctx.stroke();
    }

    // ── Sparks ─────────────────────────────────────────────────
    sparks.forEach(p => {
        const chargeEffect = state.chargeEnergy;
        p.angle += p.speed * (1 + chargeEffect * 4) * dt;

        // During charge, sparks pull inward toward core
        let targetDist = p.orbitRadius;
        if (chargeEffect > 0.01) {
            targetDist = innerRadius * (1 - chargeEffect * 0.6);
        }
        p.dist += (targetDist - p.dist) * 0.05 * dt;

        const px = cx + Math.cos(p.angle) * p.dist;
        const py = cy + Math.sin(p.angle) * p.dist;
        p.trail.push({ x: px, y: py });
        const maxTrail = state.isMobile ? 8 : 14;
        while (p.trail.length > maxTrail) p.trail.shift();

        // Draw trail
        const distFade = Math.max(0, Math.min(1, (p.dist - 5) / 30));
        for (let ti = 0; ti < p.trail.length; ti++) {
            const t = p.trail[ti];
            const progress = (ti + 1) / p.trail.length;
            const sz = p.size * progress * (0.3 + distFade * 0.7);
            ctx.globalAlpha = progress * 0.55 * distFade;
            ctx.fillStyle = theme.spark;
            ctx.beginPath();
            ctx.arc(t.x, t.y, sz, 0, TWO_PI);
            ctx.fill();
        }
    });

    // ── Ripples (safe reverse iteration) ───────────────────────
    for (let i = ripples.length - 1; i >= 0; i--) {
        const r = ripples[i];
        const edgeFade = 1 - r.r / maxScreenDist;

        ctx.globalAlpha = r.a * 0.35 * Math.max(0, edgeFade);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = r.isHour ? 2 : 1.2;
        drawCircle(cx, cy, Math.max(0, r.r));
        ctx.stroke();

        if (!r.reflected) {
            r.r += r.v * dt;
            if (r.isHour && r.r > maxScreenDist) {
                r.reflected = true;
            } else if (!r.isHour && r.r > maxClockRadius * 1.6) {
                r.a -= 0.04 * dt;
                if (r.a <= 0) ripples.splice(i, 1);
            }
        } else {
            r.r -= r.v * 1.4 * dt;
            if (r.r <= innerRadius * 0.5) {
                // THE CRASH
                state.coreFlash = 5.5;
                minuteRings.forEach(ring => { ring.glow = 0; });
                // Burst sparks outward
                sparks.forEach(p => { p.dist = baseSize * 0.38; });
                ripples.splice(i, 1);
            }
        }
    }

    // ── Touch Ripples (safe reverse iteration) ─────────────────
    for (let i = touchRipples.length - 1; i >= 0; i--) {
        const r = touchRipples[i];
        ctx.globalAlpha = r.a * 0.3;
        ctx.strokeStyle = theme.spark;
        ctx.lineWidth = 1.5;
        drawCircle(r.x, r.y, r.r);
        ctx.stroke();
        r.r += r.v * dt;
        r.a -= 0.015 * dt;
        if (r.a <= 0) touchRipples.splice(i, 1);
    }

    // ── Agent Core ─────────────────────────────────────────────
    const coreSize = baseSize * 0.07;
    const breathCycle = Math.sin(timestamp * 0.0015);
    const breath = 1 + breathCycle * 0.04 - state.chargeEnergy * 0.25;
    const coreRadius = coreSize * breath;

    // Outer glow halo
    ctx.globalAlpha = 0.15 + state.coreFlash * 0.08;
    const haloGrad = ctx.createRadialGradient(cx, cy, coreRadius, cx, cy, coreRadius * 3);
    haloGrad.addColorStop(0, theme.core);
    haloGrad.addColorStop(1, "transparent");
    ctx.fillStyle = haloGrad;
    drawCircle(cx, cy, coreRadius * 3);
    ctx.fill();

    // Core flash (white burst on minute fire)
    if (state.coreFlash > 0.5) {
        ctx.globalAlpha = Math.min(0.6, state.coreFlash * 0.15);
        const flashGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreRadius * 2.5);
        flashGrad.addColorStop(0, "#fff");
        flashGrad.addColorStop(1, "transparent");
        ctx.fillStyle = flashGrad;
        drawCircle(cx, cy, coreRadius * 2.5);
        ctx.fill();
    }

    // Inner core
    ctx.globalAlpha = 0.95;
    const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreRadius * 1.3);
    coreGrad.addColorStop(0, "#fff");
    coreGrad.addColorStop(0.4, theme.core);
    coreGrad.addColorStop(1, "transparent");
    ctx.fillStyle = coreGrad;
    drawCircle(cx, cy, coreRadius * 1.3);
    ctx.fill();

    // Charge indicator: ring tightens around core
    if (state.chargeEnergy > 0.02) {
        const chargeRadius = coreRadius * (1.8 - state.chargeEnergy * 0.6);
        ctx.globalAlpha = state.chargeEnergy * 0.7;
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1 + state.chargeEnergy * 2;
        drawCircle(cx, cy, chargeRadius);
        ctx.stroke();
    }

    // ── Hour Marker Dots ───────────────────────────────────────
    // 12 dots around outer edge for hour reading
    const hourDotRadius = maxClockRadius + baseSize * 0.05;
    const currentHour = theme.h % 12;
    for (let hd = 0; hd < 12; hd++) {
        const angle = (hd / 12) * TWO_PI - Math.PI / 2;
        const hx = cx + Math.cos(angle) * hourDotRadius;
        const hy = cy + Math.sin(angle) * hourDotRadius;
        const isCurrentHour = hd === currentHour;
        const isCardinal = hd % 3 === 0;

        const dotSize = isCardinal
            ? (state.isMobile ? 3.5 : 4.5)
            : (state.isMobile ? 1.8 : 2.2);

        ctx.globalAlpha = isCurrentHour ? 0.9 : (isCardinal ? 0.35 : 0.15);
        ctx.fillStyle = isCurrentHour ? "#fff" : theme.quarter;
        ctx.beginPath();
        ctx.arc(hx, hy, dotSize, 0, TWO_PI);
        ctx.fill();

        // Current hour: add glow
        if (isCurrentHour) {
            ctx.globalAlpha = 0.25 + Math.sin(timestamp * 0.002) * 0.1;
            const hourGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, dotSize * 4);
            hourGlow.addColorStop(0, "#fff");
            hourGlow.addColorStop(1, "transparent");
            ctx.fillStyle = hourGlow;
            ctx.beginPath();
            ctx.arc(hx, hy, dotSize * 4, 0, TWO_PI);
            ctx.fill();
        }
    }

    // ── Time Ghost Label ───────────────────────────────────────
    if (state.ghostAlpha > 0.01) {
        const h12 = theme.h % 12 || 12;
        const mPad = theme.m < 10 ? '0' + theme.m : '' + theme.m;
        const ampm = theme.h < 12 ? 'am' : 'pm';
        const timeStr = `${h12}:${mPad} ${ampm}`;

        ctx.save();
        ctx.globalAlpha = Math.min(state.ghostAlpha, 0.6);
        ctx.fillStyle = "#fff";
        ctx.font = `200 ${baseSize * (state.isMobile ? 0.055 : 0.05)}px system-ui, sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(timeStr, cx, cy + maxClockRadius + baseSize * 0.1);
        ctx.restore();
    }

    // ── Second Progress Arc ────────────────────────────────────
    // Visible arc on the active ring with a leading dot cursor
    if (passedRings < 60) {
        const activeRing = minuteRings[passedRings];
        if (activeRing) {
            const secProgress = theme.secFrac / 60;
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + secProgress * TWO_PI;
            const arcRadius = activeRing.r;

            // The arc itself
            ctx.globalAlpha = 0.3 + state.chargeEnergy * 0.4;
            ctx.strokeStyle = theme.core;
            ctx.lineWidth = state.isMobile ? 2.0 : 2.8;
            ctx.beginPath();
            ctx.arc(cx, cy, arcRadius, startAngle, endAngle);
            ctx.stroke();

            // Leading dot at the arc's head
            const dotX = cx + Math.cos(endAngle) * arcRadius;
            const dotY = cy + Math.sin(endAngle) * arcRadius;
            const dotSize = state.isMobile ? 3 : 4;

            // Dot glow
            ctx.globalAlpha = 0.25 + state.chargeEnergy * 0.3;
            const dotGlow = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, dotSize * 3);
            dotGlow.addColorStop(0, theme.core);
            dotGlow.addColorStop(1, "transparent");
            ctx.fillStyle = dotGlow;
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotSize * 3, 0, TWO_PI);
            ctx.fill();

            // Dot core
            ctx.globalAlpha = 0.8 + state.chargeEnergy * 0.2;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(dotX, dotY, dotSize, 0, TWO_PI);
            ctx.fill();
        }
    }

    // Reset alpha
    ctx.globalAlpha = 1;

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

})();
</script>
</body>
</html>
